name: Build

# Run this workflow every time a new commit pushed to your repository

on: pull_request

env:
  DOTNET_NOLOGO: 1
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true
  CCACHE_COMPILERCHECK: none

jobs:
  macos:
    name: Build MacOS dylib (x86-64 and arm64)
    runs-on: macos-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
      - name: ccache
        uses: hendrikmuhs/ccache-action@v1.2
        with:
          key: ${{ github.job }}-${{ matrix.os }}
      - name: Cache autoconf
        uses: actions/cache@v4
        with:
          path: configcache
          key: macos-configcache-ccache-v1
      - name: Build
        run: |
          export PATH="/usr/lib/ccache:/usr/local/opt/ccache/libexec:$PATH"
          export CCACHE_COMPILERCHECK=content
          ./native/build-macos.sh
      - name: Archive MacOS library
        uses: actions/upload-artifact@v4
        with:
          name: maclib
          path: libarchive.dylib
          if-no-files-found: error
          retention-days: 1
  linux:
    needs: [macos]
    name: Build Windows DLLs, Linux library, and test
    runs-on: ubuntu-22.04
    steps:
      - name: Ubuntu packages
        run: sudo apt-get install -y libeatmydata1
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
      - name: Extract version from tag
        id: version
        run: |
          if [[ $GITHUB_REF == refs/tags/v* ]]; then
            VERSION=${GITHUB_REF#refs/tags/v}
            echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
            echo "IS_RELEASE=true" >> $GITHUB_OUTPUT
          else
            VERSION="0.0.0-dev"
            echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
            echo "IS_RELEASE=false" >> $GITHUB_OUTPUT
          fi
          echo "Extracted version: $VERSION"
      - name: Retrieve MacOS library
        uses: actions/download-artifact@v5
        with:
          name: maclib
      - name: Install MinGW for Windows cross-compilation
        run: |
          sudo apt-get update
          sudo apt-get install -y mingw-w64
          # Install LLVM-MinGW for ARM64
          curl -sL https://github.com/mstorsjo/llvm-mingw/releases/download/20240619/llvm-mingw-20240619-ucrt-ubuntu-20.04-x86_64.tar.xz | tar xJ
          echo "$(pwd)/llvm-mingw-20240619-ucrt-ubuntu-20.04-x86_64/bin" >> $GITHUB_PATH
      - name: Setup .NET Core
        uses: actions/setup-dotnet@v5.0.0
      - name: ccache
        uses: hendrikmuhs/ccache-action@v1.2
        with:
          key: all-native-builds
      - name: Setup ccache for MinGW
        run: |
          mkdir -p $HOME/.ccache-bin
          for arch in i686 x86_64 aarch64; do
            for tool in gcc g++; do
              ln -sf $(which ccache) $HOME/.ccache-bin/${arch}-w64-mingw32-$tool
            done
          done
          echo "$HOME/.ccache-bin" >> $GITHUB_PATH
      - name: Cache autoconf
        uses: actions/cache@v4
        with:
          path: configcache
          key: all-native-configcache-v1
      - name: Build Windows DLLs (x86, x64, arm64)
        run: |
          export CCACHE_COMPILERCHECK=content

          # Build each architecture in separate directory to avoid conflicts
          for arch in x86 x64 arm64; do
            echo "=== Building Windows $arch ==="
            mkdir -p build-win-$arch
            cd build-win-$arch

            # Use architecture-specific config cache
            export CONFIGCACHE="$(pwd)/configcache-$arch"
            export PREFIX="$(pwd)/local-$arch"

            ARCH=$arch ../native/build-windows.sh
            mv archive-*.dll ../
            cd ..

            # Clean up to avoid conflicts with next architecture
            rm -rf build-win-$arch
            echo "âœ“ Windows $arch build complete"
          done

          ls -lh archive-*.dll
      - name: Build Linux library
        run: |
          export PATH="/usr/lib/ccache:/usr/local/opt/ccache/libexec:$PATH"
          export CCACHE_COMPILERCHECK=content
          ./native/build-linux.sh
      - name: Initialize CodeQL
        uses: github/codeql-action/init@v4
        with:
          languages: 'csharp'
          build-mode: manual
      - name: Built .Net package and test
        run: |
          mkdir -p LibArchive.Net/runtimes/{osx-x64,osx-arm64,linux-x64,linux-musl-x64,win-x86,win-x64,win-arm64}/native

          # Linux
          mv libarchive.so LibArchive.Net/runtimes/linux-x64/native/
          cp LibArchive.Net/runtimes/linux-x64/native/libarchive.so LibArchive.Net/runtimes/linux-musl-x64/native/

          # macOS
          mv libarchive.dylib LibArchive.Net/runtimes/osx-x64/native/
          cp LibArchive.Net/runtimes/osx-x64/native/libarchive.dylib LibArchive.Net/runtimes/osx-arm64/native/

          # Windows
          mv archive-x86.dll LibArchive.Net/runtimes/win-x86/native/archive.dll
          mv archive-x64.dll LibArchive.Net/runtimes/win-x64/native/archive.dll
          mv archive-arm64.dll LibArchive.Net/runtimes/win-arm64/native/archive.dll

          touch libarchive.dylib

          # Build and pack the library first
          dotnet pack LibArchive.Net/LibArchive.Net.csproj -o . -p:PackageVersion=${{ steps.version.outputs.VERSION }} --configuration Release --nologo

          # Extract package info
          PACKAGE_FILE=$(ls LibArchive.Net.*.nupkg)
          PACKAGE_VERSION=$(echo "$PACKAGE_FILE" | sed 's/LibArchive.Net.\(.*\).nupkg/\1/')
          echo "=== Package: $PACKAGE_FILE (version: $PACKAGE_VERSION) ==="
          unzip -l "$PACKAGE_FILE" | grep -E "runtimes/|\.targets|lib/"

          # Clear old cached versions to force using local package
          rm -rf ~/.nuget/packages/libarchive.net/

          # Restore and test using the local NuGet package
          echo "=== Testing with local NuGet package version $PACKAGE_VERSION ==="
          # Use local source first, then nuget.org for other dependencies
          dotnet restore Test.LibArchive.Net/Test.LibArchive.Net.csproj --source . --source https://api.nuget.org/v3/index.json /p:UseLocalPackage=true /p:LibArchiveNetVersion=$PACKAGE_VERSION

          # Verify the correct version was restored
          echo "=== Restored LibArchive.Net version ==="
          ls -la ~/.nuget/packages/libarchive.net/

          dotnet build Test.LibArchive.Net/Test.LibArchive.Net.csproj --configuration Release --no-restore /p:UseLocalPackage=true /p:LibArchiveNetVersion=$PACKAGE_VERSION

          # Debug: Show test output directory
          echo "=== Test output directory ==="
          ls -laR Test.LibArchive.Net/bin/Release/net9.0/runtimes/ 2>/dev/null || echo "No runtimes folder in test output!"

          # Run tests for net9.0
          echo "=== Running tests for net9.0 ==="
          dotnet test Test.LibArchive.Net/Test.LibArchive.Net.csproj --framework net9.0 --configuration Release --no-build --nologo /p:UseLocalPackage=true /p:LibArchiveNetVersion=$PACKAGE_VERSION

      - name: Install Mono for .NET Framework tests
        run: |
          sudo apt-get update
          sudo apt-get install -y mono-complete mono-devel
          mono --version

      - name: Run .NET Framework tests with Mono
        run: |
          PACKAGE_VERSION=$(ls LibArchive.Net.*.nupkg | sed 's/LibArchive.Net.\(.*\).nupkg/\1/')

          echo "=== Running tests for net462 with Mono ==="
          dotnet test Test.LibArchive.Net/Test.LibArchive.Net.csproj --framework net462 --configuration Release --no-build --verbosity normal /p:UseLocalPackage=true /p:LibArchiveNetVersion=$PACKAGE_VERSION

      - name: Cleanup build artifacts
        run: |
          ls -lh *.nupkg
          du -sh *
          rm -rf local {bzip2,libarchive,libxml2,lz4,lzo,xz,zlib,zstd}-* x86-64--musl--stable-*
      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v4
      - name: Upload built packages
        uses: svenstaro/upload-release-action@2.11.2
        if: contains(github.ref, 'refs/tags/v')
        with:
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          file: '*.nupkg'
          tag: ${{ github.ref }}
          overwrite: true
          file_glob: true
      - name: Archive production artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist
          path: |
            *.nupkg
      - name: Upload built packages
        uses: svenstaro/upload-release-action@2.11.2
        if: contains(github.ref, 'refs/tags/v')
        with:
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          file: '*.nupkg'
          tag: ${{ github.ref }}
          overwrite: true
          file_glob: true
      - name: Upload Nuget package
        if: contains(github.ref, 'refs/tags/v')
        run: dotnet nuget push *.nupkg -k ${{ secrets.NUGET_KEY }} --source https://api.nuget.org/v3/index.json
