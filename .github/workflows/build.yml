name: Build

# Run this workflow every time a new commit pushed to your repository

on: pull_request

env:
  DOTNET_NOLOGO: 1
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true

jobs:
  macos:
    name: Build MacOS dylib (x86-64 and arm64)
    runs-on: macos-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
      - name: Cache library downloads
        uses: actions/cache@v4
        with:
          path: ~/downloads
          key: library-downloads-${{ hashFiles('native/build-config.sh') }}
          restore-keys: |
            library-downloads-
      - name: ccache
        uses: hendrikmuhs/ccache-action@v1.2
        with:
          key: macos-build-v2
        env:
          CCACHE_COMPILERCHECK: mtime
      - name: Build
        run: |
          export PATH="/usr/lib/ccache:/usr/local/opt/ccache/libexec:$PATH"
          export CC="ccache clang"
          export CXX="ccache clang++"

          echo "=== ccache stats before build ==="
          ccache -s

          ./native/build-macos.sh

          echo "=== ccache stats after build ==="
          ccache -s
      - name: Archive MacOS library
        uses: actions/upload-artifact@v5
        with:
          name: maclib
          path: ~/libarchive-native/libarchive.dylib
          if-no-files-found: error
          retention-days: 1
  linux:
    needs: [macos]
    name: Build Windows DLLs, Linux library, and test
    runs-on: ubuntu-24.04
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
      - name: Cache library downloads
        uses: actions/cache@v4
        with:
          path: ~/downloads
          key: library-downloads-${{ hashFiles('native/build-config.sh') }}
          restore-keys: |
            library-downloads-
      - name: Extract version from tag
        id: version
        run: |
          if [[ $GITHUB_REF == refs/tags/v* ]]; then
            VERSION=${GITHUB_REF#refs/tags/v}
            echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
            echo "IS_RELEASE=true" >> $GITHUB_OUTPUT
          else
            VERSION="0.0.0-dev"
            echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
            echo "IS_RELEASE=false" >> $GITHUB_OUTPUT
          fi
          echo "Extracted version: $VERSION"
      - name: Cache apt packages
        uses: awalsh128/cache-apt-pkgs-action@v1.6.0
        with:
          packages: libeatmydata1 mingw-w64 mono-complete mono-devel pkg-config
          version: 1.0
          execute_install_scripts: true
      - name: Retrieve MacOS library
        uses: actions/download-artifact@v6
        with:
          name: maclib
      - name: Install LLVM-MinGW for ARM64
        run: |
          curl -sL https://github.com/mstorsjo/llvm-mingw/releases/download/20240619/llvm-mingw-20240619-ucrt-ubuntu-20.04-x86_64.tar.xz | tar xJ
          echo "$(pwd)/llvm-mingw-20240619-ucrt-ubuntu-20.04-x86_64/bin" >> $GITHUB_PATH
      - name: Setup .NET Core
        uses: actions/setup-dotnet@v5.0.1
        with:
          cache: true
          cache-dependency-path: '**/*.csproj'
      - name: Update Directory.Build.props for SDK version
        run: ./scripts/generate-build-props.sh
      - name: ccache
        uses: hendrikmuhs/ccache-action@v1.2
        with:
          key: all-native-builds-v2
          variant: sccache
        env:
          CCACHE_COMPILERCHECK: mtime
      - name: Verify MinGW compilers are installed
        run: |
          echo "Checking for MinGW compilers..."
          which i686-w64-mingw32-gcc || echo "WARNING: i686-w64-mingw32-gcc not found"
          which x86_64-w64-mingw32-gcc || echo "WARNING: x86_64-w64-mingw32-gcc not found"
          ls -la /usr/bin/*mingw32* || true
      - name: Setup sccache wrappers for all compilers
        run: |
          mkdir -p $HOME/.ccache-bin

          # Use LLVM-MinGW for all Windows architectures (x86, x64, arm64)
          # This provides a consistent, modern toolchain across all targets
          LLVM_MINGW_BIN="$(pwd)/llvm-mingw-20240619-ucrt-ubuntu-20.04-x86_64/bin"

          for arch in i686 x86_64 aarch64; do
            for tool in gcc g++; do
              echo '#!/bin/sh' > $HOME/.ccache-bin/${arch}-w64-mingw32-$tool
              echo "exec sccache $LLVM_MINGW_BIN/${arch}-w64-mingw32-${tool} \"\$@\"" >> $HOME/.ccache-bin/${arch}-w64-mingw32-$tool
              chmod +x $HOME/.ccache-bin/${arch}-w64-mingw32-$tool
            done
          done

          echo "$HOME/.ccache-bin" >> $GITHUB_PATH
      - name: Install autoconf and automake
        run: |
          # xz 5.8+ requires automake 1.17 and autoconf 2.72
          # Use ftpmirror.gnu.org to auto-select nearest mirror (more reliable than ftp.gnu.org)
          # Install autoconf 2.72
          curl -sSL --retry 3 --retry-delay 5 https://ftpmirror.gnu.org/gnu/autoconf/autoconf-2.72.tar.xz | tar xJ
          cd autoconf-2.72
          ./configure --prefix=$HOME/.local
          make -j$(nproc)
          make install
          cd ..
          # Install automake 1.17
          curl -sSL --retry 3 --retry-delay 5 https://ftpmirror.gnu.org/gnu/automake/automake-1.17.tar.xz | tar xJ
          cd automake-1.17
          ./configure --prefix=$HOME/.local
          make -j$(nproc)
          make install
          echo "$HOME/.local/bin" >> $GITHUB_PATH
          # Set ACLOCAL_PATH to include system m4 files (for pkg.m4 etc)
          echo "ACLOCAL_PATH=/usr/share/aclocal:$HOME/.local/share/aclocal" >> $GITHUB_ENV
      - name: Download library sources once
        run: |
          # Load the download function and download all libraries once
          . native/build-config.sh
          download_all_libraries

      - name: Build Windows DLLs (x86, x64, arm64)
        run: |
          echo "=== sccache stats before build ==="
          sccache --show-stats

          # Build each architecture in separate directory to avoid conflicts
          for arch in x86 x64 arm64; do
            echo "=== Building Windows $arch ==="
            mkdir -p build-win-$arch
            cd build-win-$arch

            # Use architecture-specific prefix
            export PREFIX="$(pwd)/local-$arch"

            # Copy library sources from parent directory (already downloaded)
            # Use -rpl to hardlink and preserve timestamps (important for xz automake fix)
            for src in ../bzip2-* ../libarchive-* ../libxml2-* ../lz4-* ../lzo-* ../xz-* ../zlib-* ../zstd-*; do
              [ -e "$src" ] && cp -rpl "$src" .
            done

            ARCH=$arch ../native/build-windows.sh
            mv archive-*.dll ../
            cd ..

            # Clean up to avoid conflicts with next architecture
            rm -rf build-win-$arch
            echo "âœ“ Windows $arch build complete"
          done

          echo "=== sccache stats after Windows build ==="
          sccache --show-stats

          ls -lh archive-*.dll
      - name: Build Linux libraries (x86, x64, arm64, arm)
        run: |
          # Each build script handles its own toolchain and sccache setup

          # Build x86 (32-bit)
          echo "=== Building Linux x86 ==="
          ./native/build-linux-x86.sh

          # Build x64
          echo "=== Building Linux x64 ==="
          ./native/build-linux.sh

          # Build arm64
          echo "=== Building Linux ARM64 ==="
          ./native/build-linux-arm64.sh

          # Build armv7
          echo "=== Building Linux ARM v7 ==="
          ./native/build-linux-arm.sh

          echo "=== sccache stats after Linux builds ==="
          sccache --show-stats

          ls -lh $HOME/libarchive-native/
      - name: Initialize CodeQL
        uses: github/codeql-action/init@v4
        with:
          languages: 'csharp'
          build-mode: manual
      - name: Built .Net package and test
        run: |
          mkdir -p LibArchive.Net/runtimes/{osx-x64,osx-arm64,linux-x86,linux-musl-x86,linux-x64,linux-musl-x64,linux-arm,linux-musl-arm,linux-arm64,linux-musl-arm64,win-x86,win-x64,win-arm64}/native

          # Linux x86 (32-bit)
          cp $HOME/libarchive-native/libarchive-linux-x86.so LibArchive.Net/runtimes/linux-x86/native/libarchive.so
          cp LibArchive.Net/runtimes/linux-x86/native/libarchive.so LibArchive.Net/runtimes/linux-musl-x86/native/

          # Linux x64
          cp $HOME/libarchive-native/libarchive-linux-x64.so LibArchive.Net/runtimes/linux-x64/native/libarchive.so
          cp LibArchive.Net/runtimes/linux-x64/native/libarchive.so LibArchive.Net/runtimes/linux-musl-x64/native/

          # Linux ARM64
          cp $HOME/libarchive-native/libarchive-linux-arm64.so LibArchive.Net/runtimes/linux-arm64/native/libarchive.so
          cp LibArchive.Net/runtimes/linux-arm64/native/libarchive.so LibArchive.Net/runtimes/linux-musl-arm64/native/

          # Linux ARM v7
          cp $HOME/libarchive-native/libarchive-linux-arm.so LibArchive.Net/runtimes/linux-arm/native/libarchive.so
          cp LibArchive.Net/runtimes/linux-arm/native/libarchive.so LibArchive.Net/runtimes/linux-musl-arm/native/

          # macOS (downloaded as artifact to current directory)
          cp libarchive.dylib LibArchive.Net/runtimes/osx-x64/native/
          cp LibArchive.Net/runtimes/osx-x64/native/libarchive.dylib LibArchive.Net/runtimes/osx-arm64/native/

          # Windows
          mv archive-x86.dll LibArchive.Net/runtimes/win-x86/native/archive.dll
          mv archive-x64.dll LibArchive.Net/runtimes/win-x64/native/archive.dll
          mv archive-arm64.dll LibArchive.Net/runtimes/win-arm64/native/archive.dll

          touch libarchive.dylib

          # Build and pack the library first
          dotnet pack LibArchive.Net/LibArchive.Net.csproj -o . -p:PackageVersion=${{ steps.version.outputs.VERSION }} --configuration Release --nologo

          # Extract package info
          PACKAGE_FILE=$(ls LibArchive.Net.*.nupkg)
          PACKAGE_VERSION=$(echo "$PACKAGE_FILE" | sed 's/LibArchive.Net.\(.*\).nupkg/\1/')
          echo "=== Package: $PACKAGE_FILE (version: $PACKAGE_VERSION) ==="
          unzip -l "$PACKAGE_FILE" | grep -E "runtimes/|\.targets|lib/"

          # Clear old cached versions to force using local package
          rm -rf ~/.nuget/packages/libarchive.net/

          # Restore and test using the local NuGet package
          echo "=== Testing with local NuGet package version $PACKAGE_VERSION ==="
          # Use local source first, then nuget.org for other dependencies
          dotnet restore Test.LibArchive.Net/Test.LibArchive.Net.csproj --source . --source https://api.nuget.org/v3/index.json /p:UseLocalPackage=true /p:LibArchiveNetVersion=$PACKAGE_VERSION

          # Verify the correct version was restored
          echo "=== Restored LibArchive.Net version ==="
          ls -la ~/.nuget/packages/libarchive.net/

          # Build tests (uses latest .NET from Directory.Build.props)
          dotnet build Test.LibArchive.Net/Test.LibArchive.Net.csproj --configuration Release --no-restore /p:UseLocalPackage=true /p:LibArchiveNetVersion=$PACKAGE_VERSION

          # Debug: Show test output directory
          echo "=== Test output directory ==="
          ls -laR Test.LibArchive.Net/bin/Release/*/runtimes/ 2>/dev/null || echo "No runtimes folder in test output!"

          # Run tests
          echo "=== Running tests ==="
          dotnet test Test.LibArchive.Net/Test.LibArchive.Net.csproj --configuration Release --no-build --nologo /p:UseLocalPackage=true /p:LibArchiveNetVersion=$PACKAGE_VERSION

      - name: Cleanup build artifacts
        run: |
          ls -lh *.nupkg
          du -sh *
          rm -rf local {bzip2,libarchive,libxml2,lz4,lzo,xz,zlib,zstd}-* x86-64--musl--stable-*
      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v4
      - name: Upload built packages
        uses: svenstaro/upload-release-action@2.11.3
        if: contains(github.ref, 'refs/tags/v')
        with:
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          file: '*.nupkg'
          tag: ${{ github.ref }}
          overwrite: true
          file_glob: true
      - name: Archive production artifacts
        uses: actions/upload-artifact@v5
        with:
          name: dist
          path: |
            *.nupkg
      - name: Upload built packages
        uses: svenstaro/upload-release-action@2.11.3
        if: contains(github.ref, 'refs/tags/v')
        with:
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          file: '*.nupkg'
          tag: ${{ github.ref }}
          overwrite: true
          file_glob: true
      - name: Upload Nuget package
        if: contains(github.ref, 'refs/tags/v')
        run: dotnet nuget push *.nupkg -k ${{ secrets.NUGET_KEY }} --source https://api.nuget.org/v3/index.json
